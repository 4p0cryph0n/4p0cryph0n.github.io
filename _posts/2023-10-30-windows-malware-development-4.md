---
title: "Windows Malware Development Part 4: Payload Placement Basics - .rsrc"
header:
  teaser: /assets/images/pe.png
  teaser_home_page: true
categories:
  - Malware Dev
classes: wide
tags:
  - Malware
toc: true
toc_label: Contents
---
## Objective ##

Hey guys, welcome to the fourth part of Windows Malware Development, in which we will be looking at the final part of the basics of payload placement. In this post, we will be looking at how to place our shellcode in the `.rsrc` section.

## .rsrc Section ##

If you recall from the PE file structure post, the `.rsrc` section contains any resources that our program needs to load in order to function. From a Malware development perspective however, we can use this section our advantage. Our shellcode will now be hidden in the resources section of our program, away from plain sight.

>You will need Visual Studio/Visual studio build tools, x64dbg and Metasploit (comes with a build of Kali Linux) for this exercise.
>
>For this post, I will be using the Visual Studio GUI for the purposes of simplicity, since its easier to create and add a resource using the GUI. However, it is still possible without it.

We will be changing our shellcode in this post to actually execute something, and in the process learn how to use the Metasploit Framework in order to generate shellcode.

## Creating the Shellcode and Resource File ##

### Generating Shellcode using the Metasploit Framework ###

Readers who come from a penetration testing and red teaming background would know that the Metasploit Framework offers many tools that aid with these tasks. One of those tools is `msfvenom`, which is a console tool that can be used to generate different types of payloads and shellcode.

We will be using `msfvenom` in order to generate shellcode that launches `calc.exe` (The Windows Calculator) using `CMD`.

```sh
┌──(kali㉿kali)-[~]
└─$ msfvenom -p windows/x64/exec CMD=calc.exe > pay.ico 
```

- `-p windows/x64/exec`: This is the payload type. There are many types of payloads, for example, if you want to generate a reverse shell shellcode you will be using a different payload type. In this case, we are using a command execution payload type.
- `CMD= calc.exe`: The command that we wish to execute, which in this case, is `calc.exe`.
- `> pay.ico`: The output file containing our shellcode. You can use any acceptable resource file extension, but in this case we will be using the `.ico` (ICON file) extension.

If we try to view our file, it will appear to be a bunch of binary data, however, we can see the word `calc.exe`:

```
┌──(kali㉿kali)-[~]
└─$ cat '/home/kali/Desktop/pay.ico'       
A�8�u�LLE9�u�XD�@$I�fA�H�P�H▒D�@ I��VH��A�4�H�M1�H1��A��
                       HD�@I�A��H�AXAX^YZAXAYAZH�� AR��XAYZH��W���]H�H��A�1�o��ջ���VA�������H��(<|
���u�GrojYA����calc.exe 
```

### Adding the File as a Resource ###

Now that our shellcode file is ready, let's add it as a resource for our program. 

- Start by creating a blank C++ project in Visual Studio. 
- In the solution explorer pane (right-hand side of the screen), right-click on the Resource Files icon, and select Add > New Item and view all the templates.
- Select Resource from the left pane and add a Resource File (.rc). Leave the name as is.
- You will see a new pane labeled Resource View open in place of the solution explorer. Right-click on the Resource.rc icon and click on Add Resource.
- In the new window, click on Import, and import your `.ico` shellcode file.
- Enter `RCDATA` as the Resource Type and click OK.

![RCDATA](/assets/images/rcdata.png)

- You will now see your resource displayed as binary data.

Navigate back to the solution explorer pane and have a look at the `resource.h` header file. The `#define` statement that you see is your payload's ID in the `.rsrc` section (in this case, `IDR_RCDATA1`), and will be needed later when we're loading it,

```cpp
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Resource.rc
//
#define IDR_RCDATA1                     101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
```

## Writing the program ##

Start off by adding a C++ file to you project (if not done already). Let's start writing the program. The flow would go as follows:

- Fetch resource location.
- Fetch a handle to the global memory block (`hGlobal`).
- Get the address of our shellcode in the `.rsrc` section.
- Get the size of our shellcode.
- Copy to an executable memory buffer.
- Execute it.

### Fetching the location of our resource ###

We will be using the `FindResourceW` API for this operation. Taking a look at the documentation, we can see that it takes three parameters:

```cpp
HRSRC FindResourceW(
  [in, optional] HMODULE hModule,
  [in]           LPCWSTR lpName,
  [in]           LPCWSTR lpType
);
```

